diff -uNr qt-everywhere-opensource-src-4.8.5.org/src/3rdparty/powervr/pvr2d.h qt-everywhere-opensource-src-4.8.5/src/3rdparty/powervr/pvr2d.h
--- qt-everywhere-opensource-src-4.8.5.org/src/3rdparty/powervr/pvr2d.h	2013-06-07 07:16:52.000000000 +0200
+++ qt-everywhere-opensource-src-4.8.5/src/3rdparty/powervr/pvr2d.h	2013-12-16 13:53:10.800503804 +0100
@@ -1,16 +1,43 @@
-/*!****************************************************************************
-@File          pvr2d.h
-@Title         PVR2D external header file
-@Author        Imagination Technologies
-@Copyright     Copyright (c) by Imagination Technologies Limited.
-				This specification is protected by copyright laws and contains
-				material proprietary to Imagination Technologies Limited.
-				You may use and distribute this specification free of charge for implementing
-				the functionality therein, without altering or removing any trademark, copyright,
-				or other notice from the specification.
-@Platform      Generic
-@Description   PVR2D definitions for PVR2D clients
-******************************************************************************/
+/*************************************************************************/ /*!
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+ 
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+*/ /**************************************************************************/
 
 
 /******************************************************************************
@@ -23,22 +50,46 @@
 
 #ifdef __cplusplus
 extern "C" {
-#endif
+#endif 
 
 /* PVR2D Platform-specific definitions */
+#if defined (__linux__)
+#define PVR2D_EXPORT __attribute__((visibility("default")))
+#define PVR2D_IMPORT
+#else
 #define PVR2D_EXPORT
 #define PVR2D_IMPORT
+#endif
 
+/* PVR2D header revision */
+#define PVR2D_REV_MAJOR		3
+#define PVR2D_REV_MINOR		6
 
-#define PVR2D_REV_MAJOR		2
-#define PVR2D_REV_MINOR		1
-
+/* Basic types */
 typedef enum
 {
 	PVR2D_FALSE = 0,
 	PVR2D_TRUE
 } PVR2D_BOOL;
 
+typedef void* PVR2D_HANDLE;
+
+typedef char             PVR2D_CHAR,	*PVR2D_PCHAR;
+typedef unsigned char    PVR2D_UCHAR,	*PVR2D_PUCHAR;
+
+typedef int              PVR2D_INT,		*PVR2D_PINT;
+typedef unsigned int     PVR2D_UINT,	*PVR2D_PUINT;
+
+typedef unsigned short	 PVR2D_UINT16,	*PVR2D_PUINT16;
+typedef signed short	 PVR2D_INT16,	*PVR2D_PINT16;
+
+typedef long             PVR2D_LONG,	*PVR2D_PLONG;
+typedef unsigned long    PVR2D_ULONG,	*PVR2D_PULONG;
+
+typedef void             PVR2D_VOID,	*PVR2D_PVOID;
+
+/* services/stream ID */
+typedef unsigned int      PVR2D_SID;
 
 /* error codes */
 typedef enum
@@ -57,52 +108,107 @@
 	PVR2DERROR_MAPPING_FAILED = -11
 }PVR2DERROR;
 
+/* 32 bit PVR2D pixel format specifier */
+typedef unsigned long PVR2DFORMAT;
 
-/* pixel formats */
-typedef enum
-{
-	PVR2D_1BPP = 0,
-	PVR2D_RGB565,
-	PVR2D_ARGB4444,
-	PVR2D_RGB888,
-	PVR2D_ARGB8888,
-	PVR2D_ARGB1555,
-	PVR2D_ALPHA8,
-	PVR2D_ALPHA4,
-	PVR2D_PAL2,
-	PVR2D_PAL4,
-	PVR2D_PAL8,
-	PVR2D_VGAEMU
-
-}PVR2DFORMAT;
-
+/* Standard PVR2D pixel formats */
+#define	PVR2D_1BPP						0x00UL // 1bpp mask surface or palletized 1 bit source with 2x32 bit CLUT
+#define	PVR2D_RGB565					0x01UL // Common rgb 565 format
+#define	PVR2D_ARGB4444					0x02UL // Common argb 4444 format
+#define	PVR2D_RGB888					0x03UL // Common rgb 888 format
+#define	PVR2D_ARGB8888					0x04UL // Common argb 8888 format
+#define	PVR2D_ARGB1555					0x05UL // Common argb 1555 format
+#define	PVR2D_ALPHA8					0x06UL // Alpha-only 8 bit per pixel (used with a constant fill colour)
+#define	PVR2D_ALPHA4					0x07UL // Alpha-only 4 bits per pixel (used with a constant fill colour)
+#define	PVR2D_PAL2						0x08UL // Palletized 2 bit format (requires   4x32 bit CLUT)
+#define	PVR2D_PAL4						0x09UL // Palletized 4 bit format (requires  16x32 bit CLUT)
+#define	PVR2D_PAL8						0x0AUL // Palletized 8 bit format (requires 256x32 bit CLUT)
+#define PVR2D_U8						0x10UL // monochrome unsigned 8 bit
+#define PVR2D_U88						0x11UL // monochrome unsigned 16 bit
+#define PVR2D_S8						0x12UL // signed 8 bit
+#define PVR2D_YUV422_YUYV				0x13UL // YUV 422 low-high byte order Y0UY1V
+#define PVR2D_YUV422_UYVY				0x14UL // YUV 422 low-high byte order UY0VY1
+#define PVR2D_YUV422_YVYU				0x15UL // YUV 422 low-high byte order Y0VY1U
+#define PVR2D_YUV422_VYUY				0x16UL // YUV 422 low-high byte order VY0UY1
+#define PVR2D_YUV420_2PLANE				0x17UL // YUV420 2 Plane with UV interleaved in plane 2
+#define PVR2D_YUV420_3PLANE				0x18UL // YUV420 3 Plane
+#define PVR2D_2101010ARGB				0x19UL // 32 bit 2 10 10 10 
+#define PVR2D_888RSGSBS					0x1AUL // 3 channel signed 8 bit
+#define PVR2D_16BPP_RAW					0x1BUL // 16 bit raw (no format conversion)
+#define PVR2D_32BPP_RAW					0x1CUL // 32 bit raw
+#define PVR2D_64BPP_RAW					0x1DUL // 64 bit raw
+#define PVR2D_128BPP_RAW				0x1EUL // 128 bit raw
+#define PVR2D_AYUV8888					0x1FUL
+#define PVR2D_F16						0x20UL
+#define	PVR2D_NO_OF_FORMATS				0x21UL
+
+/* Format modifier bit field (DstFormat and SrcFormat bits 16..23) */
+#define PVR2D_FORMAT_MASK				0x0000FFFFUL	// PVR2D Format bits
+#define PVR2D_FORMAT_LAYOUT_MASK		0x000F0000UL	// Format layout (strided / twiddled / tiled)
+#define PVR2D_FORMAT_FLAGS_MASK			0x0FF00000UL	// Surface Flags mask
+
+/* Layout */
+#define PVR2D_FORMAT_LAYOUT_SHIFT		16
+#define PVR2D_FORMAT_LAYOUT_STRIDED		0x00000000UL
+#define PVR2D_FORMAT_LAYOUT_TILED		0x00010000UL
+#define PVR2D_FORMAT_LAYOUT_TWIDDLED	0x00020000UL
+
+/*
+	PVR2D_SURFACE_PDUMP
+	This flag requests a surface pdump, to capture the pixel state after host writes.
+	Not needed if the surface state has resulted from previous SGX 2D/3D core writes.
+*/
+#define PVR2D_SURFACE_PDUMP				0x00100000UL	// calls PVRSRVPDumpMem to capture the surface (pdump builds only) 
+#define PVR2D_BLTRECT_PDUMP				0x00200000UL	// calls PVRSRVPDumpMem to capture the blt rectangle (pdump builds only) 
+
+/*
+	Low level 3D format extension - for blts via the 3D core only.
+	If the top bit of the format field is set then PVR2D reads it as a PVRSRV_PIXEL_FORMAT.
+	The outcome is hardware dependant.
+	There is no guarantee that any specific PVRSRV format will be supported.
+*/
+#define PVR2D_FORMAT_PVRSRV				0x80000000
 
 /* wrap surface type */
 typedef enum
 {
 	PVR2D_WRAPFLAG_NONCONTIGUOUS = 0,
-	PVR2D_WRAPFLAG_CONTIGUOUS = 1,
-
+	PVR2D_WRAPFLAG_CONTIGUOUS = 1
 }PVR2DWRAPFLAGS;
 
+#define	PVR2D_CONTEXT_FLAGS_PRIORITY_MASK			0x00000003
+
+#define	PVR2D_CONTEXT_FLAGS_LOW_PRIORITY_CONTEXT	1
+#define	PVR2D_CONTEXT_FLAGS_NORMAL_PRIORITY_CONTEXT	0
+#define	PVR2D_CONTEXT_FLAGS_HIGH_PRIORITY_CONTEXT	2
+
 /* flags for control information of additional blits */
 typedef enum
 {
-	PVR2D_BLIT_DISABLE_ALL					= 0x0000,	/* disable all additional controls */
-	PVR2D_BLIT_CK_ENABLE					= 0x0001,	/* enable colour key */
-	PVR2D_BLIT_GLOBAL_ALPHA_ENABLE			= 0x0002,	/* enable standard global alpha */
-	PVR2D_BLIT_PERPIXEL_ALPHABLEND_ENABLE	= 0x0004,	/* enable per-pixel alpha bleding */
-	PVR2D_BLIT_PAT_SURFACE_ENABLE			= 0x0008,	/* enable pattern surf (disable fill) */
-	PVR2D_BLIT_FULLY_SPECIFIED_ALPHA_ENABLE	= 0x0010,	/* enable fully specified alpha */
-	PVR2D_BLIT_ROT_90						= 0x0020,	/* apply 90 degree rotation to the blt */
-	PVR2D_BLIT_ROT_180						= 0x0040,	/* apply 180 degree rotation to the blt */
-	PVR2D_BLIT_ROT_270						= 0x0080,	/* apply 270 degree rotation to the blt */
-	PVR2D_BLIT_COPYORDER_TL2BR				= 0x0100,	/* copy order overrides */
-	PVR2D_BLIT_COPYORDER_BR2TL				= 0x0200,
-	PVR2D_BLIT_COPYORDER_TR2BL				= 0x0400,
-	PVR2D_BLIT_COPYORDER_BL2TR				= 0x0800,
-	PVR2D_BLIT_COLKEY_SOURCE				= 0x1000,	/* Key colour is on the source surface */
-	PVR2D_BLIT_COLKEY_DEST					= 0x2000	/* Key colour is on the destination surface */
+	PVR2D_BLIT_DISABLE_ALL					= 0x00000000,	/* disable all additional controls */
+	PVR2D_BLIT_CK_ENABLE					= 0x00000001,	/* enable colour key */
+	PVR2D_BLIT_GLOBAL_ALPHA_ENABLE			= 0x00000002,	/* enable standard global alpha */
+	PVR2D_BLIT_PERPIXEL_ALPHABLEND_ENABLE	= 0x00000004,	/* enable per-pixel alpha blending */
+	PVR2D_BLIT_PAT_SURFACE_ENABLE			= 0x00000008,	/* enable pattern surf (disable fill) */
+	PVR2D_BLIT_FULLY_SPECIFIED_ALPHA_ENABLE	= 0x00000010,	/* enable fully specified alpha */
+	PVR2D_BLIT_ROT_90						= 0x00000020,	/* apply 90 degree rotation to the blt */
+	PVR2D_BLIT_ROT_180						= 0x00000040,	/* apply 180 degree rotation to the blt */
+	PVR2D_BLIT_ROT_270						= 0x00000080,	/* apply 270 degree rotation to the blt */
+	PVR2D_BLIT_COPYORDER_TL2BR				= 0x00000100,	/* copy order overrides */
+	PVR2D_BLIT_COPYORDER_BR2TL				= 0x00000200,
+	PVR2D_BLIT_COPYORDER_TR2BL				= 0x00000400,
+	PVR2D_BLIT_COPYORDER_BL2TR				= 0x00000800,
+	PVR2D_BLIT_COLKEY_SOURCE				= 0x00001000,	/* Key colour is on the source surface */
+	PVR2D_BLIT_COLKEY_DEST					= 0x00002000,	/* Key colour is on the destination surface */
+	PVR2D_BLIT_COLKEY_MASKED				= 0x00004000,	/* Mask enabled for colour key */
+	PVR2D_BLIT_COLKEY_OP_PASS				= 0x00008000,	/* Colour key op = pass */
+	PVR2D_BLIT_COLKEY_OP_REJECT				= 0x00010000,	/* Colour key op = reject */
+	PVR2D_BLIT_ROP4							= 0x00020000,	/* rop4 pattern support */
+	PVR2D_BLIT_PATH_2DCORE					= 0x00100000,	/* Blt via dedicated 2D Core or PTLA */
+	PVR2D_BLIT_PATH_3DCORE					= 0x00200000,	/* Blt via 3D Core */
+	PVR2D_BLIT_PATH_SWBLT					= 0x00400000,	/* Blt via host software */
+	PVR2D_BLIT_NO_SRC_SYNC_INFO				= 0x00800000,	/* Dont send a source sync info*/
+	PVR2D_BLIT_ISSUE_STATUS_UPDATES			= 0x01000000,	/* Issue SyncInfo status updates */
 
 } PVR2DBLITFLAGS;
 
@@ -113,7 +219,7 @@
 	PVR2D_ALPHA_OP_SRCP_DSTINV = 2	/* premultiplied source alpha : Cdst = Csrc + Cdst*(1-Asrc) */
 } PVR2D_ALPHABLENDFUNC;
 
-/* blend ops for fully specified alpha */
+/* blend ops for fully specified alpha (SGX 2D Core only) */
 typedef enum
 {
 	PVR2D_BLEND_OP_ZERO = 0,
@@ -125,11 +231,7 @@
 	PVR2D_BLEND_OP_DST_PLUS_GLOBAL = 6
 }PVR2D_BLEND_OP;
 
-
-typedef void* PVR2D_HANDLE;
-
-
-/* Fully specified alpha blend :	pAlpha field of PVR2DBLTINFO structure					*/
+/* SGX 2D Core Fully specified alpha blend :	pAlpha field of PVR2DBLTINFO structure		*/
 /* a fully specified Alpha Blend operation is defined as									*/
 /* DST (ALPHA) = (ALPHA_1 * SRC (ALPHA)) + (ALPHA_3 * DST (ALPHA))							*/
 /* DST (RGB)   = (ALPHA_2 * SRC (RGB)) + (ALPHA_4 * DST (RGB))								*/
@@ -152,10 +254,10 @@
 	PVR2D_BOOL		bPremulAlpha;			/* enable pre-multiplication stage */
 	PVR2D_BOOL		bTransAlpha;			/* enable transparent source alpha stage */
 	PVR2D_BOOL		bUpdateAlphaLookup;		/* enable and update the 1555-Lookup alpha table */
-	unsigned char	uAlphaLookup0;			/* 8 bit alpha when A=0 in a 1555-Lookup surface */
-	unsigned char	uAlphaLookup1;			/* 8 bit alpha when A=1 in a 1555-Lookup surface */
-	unsigned char	uGlobalRGB;				/* Global Alpha Value for RGB, 0=transparent 255=opaque */
-	unsigned char	uGlobalA;				/* Global Alpha Value for Alpha */
+	PVR2D_UCHAR		uAlphaLookup0;			/* 8 bit alpha when A=0 in a 1555-Lookup surface */
+	PVR2D_UCHAR		uAlphaLookup1;			/* 8 bit alpha when A=1 in a 1555-Lookup surface */
+	PVR2D_UCHAR		uGlobalRGB;				/* Global Alpha Value for RGB, 0=transparent 255=opaque */
+	PVR2D_UCHAR		uGlobalA;				/* Global Alpha Value for Alpha */
 
 } PVR2D_ALPHABLT, *PPVR2D_ALPHABLT;
 
@@ -163,12 +265,12 @@
 /* surface memory info structure */
 typedef struct _PVR2DMEMINFO
 {
-	void				*pBase;
-	unsigned long		ui32MemSize;
-	unsigned long		ui32DevAddr;
-	unsigned long		ulFlags;
-	void				*hPrivateData;
-	void				*hPrivateMapData;
+	PVR2D_VOID			*pBase;
+	PVR2D_ULONG			ui32MemSize;
+	PVR2D_ULONG			ui32DevAddr;
+	PVR2D_ULONG			ulFlags;
+	PVR2D_VOID			*hPrivateData;
+	PVR2D_VOID			*hPrivateMapData;
 
 }PVR2DMEMINFO, *PPVR2DMEMINFO;
 
@@ -177,88 +279,117 @@
 
 typedef struct _PVR2DDEVICEINFO
 {
-	unsigned long	ulDevID;
-	char			szDeviceName[PVR2D_MAX_DEVICE_NAME];
+	PVR2D_ULONG		ulDevID;
+	PVR2D_CHAR		szDeviceName[PVR2D_MAX_DEVICE_NAME];
 }PVR2DDEVICEINFO;
 
 
 typedef struct _PVR2DISPLAYINFO
 {
-	unsigned long	ulMaxFlipChains;
-	unsigned long	ulMaxBuffersInChain;
-	PVR2DFORMAT		eFormat;
-	unsigned long	ulWidth;
-	unsigned long	ulHeight;
-	long			lStride;
-	unsigned long	ulMinFlipInterval;
-	unsigned long	ulMaxFlipInterval;
+	PVR2D_ULONG	ulMaxFlipChains;
+	PVR2D_ULONG	ulMaxBuffersInChain;
+	PVR2DFORMAT	eFormat;
+	PVR2D_ULONG	ulWidth;
+	PVR2D_ULONG	ulHeight;
+	PVR2D_LONG	lStride;
+	PVR2D_ULONG	ulMinFlipInterval;
+	PVR2D_ULONG	ulMaxFlipInterval;
 
 }PVR2DDISPLAYINFO;
 
 
+typedef struct _PVR2MISCDISPLAYINFO
+{
+	PVR2D_ULONG ulPhysicalWidthmm;
+	PVR2D_ULONG ulPhysicalHeightmm;
+	PVR2D_ULONG ulUnused[10];
+
+}PVR2DMISCDISPLAYINFO;
+
+typedef struct
+{
+	PVR2DMEMINFO	*pSurfMemInfo;		/* surface memory */
+	PVR2D_ULONG		SurfOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
+	PVR2D_LONG		Stride;				/* signed stride */
+	PVR2DFORMAT		Format;				/* format */
+	PVR2D_ULONG		SurfWidth;			/* surface width in pixels */
+	PVR2D_ULONG		SurfHeight;			/* surface height in pixels */
+
+} PVR2D_SURFACE, *PPVR2D_SURFACE;
+
+
 typedef struct _PVR2DBLTINFO
 {
-	unsigned long	CopyCode;			/* rop code  */
-	unsigned long	Colour;				/* fill colour */
-	unsigned long	ColourKey;			/* colour key */
-	unsigned char	GlobalAlphaValue;	/* global alpha blending */
-	unsigned char	AlphaBlendingFunc;	/* per-pixel alpha-blending function */
+	PVR2D_ULONG		CopyCode;			/* rop code  */
+	PVR2D_ULONG		Colour;				/* fill colour */
+	PVR2D_ULONG		ColourKey;			/* colour key argb8888 (see CKEY_ defs below) */
+	PVR2D_UCHAR		GlobalAlphaValue;	/* global alpha blending */
+	PVR2D_UCHAR		AlphaBlendingFunc;	/* per-pixel alpha-blending function */
 
 	PVR2DBLITFLAGS	BlitFlags;			/* additional blit control information */
 
 	PVR2DMEMINFO	*pDstMemInfo;		/* destination memory */
-	unsigned long	DstOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
-	long			DstStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
-	long			DstX, DstY;			/* pixel offset from start of dest surface to start of blt rectangle */
-	long			DSizeX,DSizeY;		/* blt size */
+	PVR2D_ULONG		DstOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
+	PVR2D_LONG		DstStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		DstX, DstY;			/* pixel offset from start of dest surface to start of blt rectangle */
+	PVR2D_LONG		DSizeX,DSizeY;		/* blt size */
 	PVR2DFORMAT		DstFormat;			/* dest format */
-	unsigned long	DstSurfWidth;		/* size of dest surface in pixels */
-	unsigned long	DstSurfHeight;		/* size of dest surface in pixels */
+	PVR2D_ULONG		DstSurfWidth;		/* size of dest surface in pixels */
+	PVR2D_ULONG		DstSurfHeight;		/* size of dest surface in pixels */
 
 	PVR2DMEMINFO	*pSrcMemInfo;		/* source mem, (source fields are also used for patterns) */
-	unsigned long	SrcOffset;			/* byte offset from start of allocation to src/pat surface pixel 0,0 */
-	long			SrcStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
-	long			SrcX, SrcY;			/* pixel offset from start of surface to start of source rectangle */
+	PVR2D_ULONG		SrcOffset;			/* byte offset from start of allocation to src/pat surface pixel 0,0 */
+	PVR2D_LONG		SrcStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		SrcX, SrcY;			/* pixel offset from start of surface to start of source rectangle */
 										/* for patterns this is the start offset within the pattern */
-	long			SizeX,SizeY;		/* source rectangle size or pattern size in pixels */
+	PVR2D_LONG		SizeX,SizeY;		/* source rectangle size or pattern size in pixels */
 	PVR2DFORMAT		SrcFormat;			/* source/pattern format */
 	PVR2DMEMINFO	*pPalMemInfo;		/* source/pattern palette memory containing argb8888 colour table */
-	unsigned long	PalOffset;			/* byte offset from start of allocation to start of palette */
-	unsigned long	SrcSurfWidth;		/* size of source surface in pixels */
-	unsigned long	SrcSurfHeight;		/* size of source surface in pixels */
+	PVR2D_ULONG		PalOffset;			/* byte offset from start of allocation to start of palette */
+	PVR2D_ULONG		SrcSurfWidth;		/* size of source surface in pixels */
+	PVR2D_ULONG		SrcSurfHeight;		/* size of source surface in pixels */
 
 	PVR2DMEMINFO	*pMaskMemInfo;		/* mask memory, 1bpp format implied */
-	unsigned long	MaskOffset;			/* byte offset from start of allocation to mask surface pixel 0,0 */
-	long			MaskStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
-	long			MaskX, MaskY;		/* mask rect top left (mask size = blt size) */
-	unsigned long	MaskSurfWidth;		/* size of mask surface in pixels */
-	unsigned long	MaskSurfHeight;		/* size of mask surface in pixels */
+	PVR2D_ULONG		MaskOffset;			/* byte offset from start of allocation to mask surface pixel 0,0 */
+	PVR2D_LONG		MaskStride;			/* signed stride, the number of bytes from pixel 0,0 to 0,1 */
+	PVR2D_LONG		MaskX, MaskY;		/* mask rect top left (mask size = blt size) */
+	PVR2D_ULONG		MaskSurfWidth;		/* size of mask surface in pixels */
+	PVR2D_ULONG		MaskSurfHeight;		/* size of mask surface in pixels */
+	
+	PPVR2D_ALPHABLT pAlpha;				/* fully specified alpha blend (2DCore only) */
 	
-	PPVR2D_ALPHABLT pAlpha;				/* fully specified alpha blend */
+	PVR2D_ULONG		uSrcChromaPlane1;	/* mem offset from start of source alloc to chroma plane 1 */
+	PVR2D_ULONG		uSrcChromaPlane2;	/* mem offset from start of source alloc to chroma plane 2 */
+	PVR2D_ULONG		uDstChromaPlane1;	/* mem offset from start of dest alloc to chroma plane 1 */
+	PVR2D_ULONG		uDstChromaPlane2;	/* mem offset from start of dest alloc to chroma plane 2 */
+	
+	PVR2D_ULONG		ColourKeyMask;		/* 32 bit colour key mask, only valid when PVR2D_BLIT_COLKEY_MASKED is set */
+
+	PPVR2D_SURFACE	pPat;				/* full rop4 support for patterns if PVR2D_BLIT_ROP4 set (2D Core hardware only) */
+	PVR2D_LONG		PatX, PatY;			/* pattern start offset if PVR2D_BLIT_ROP4 set (2D Core hardware only) */
 
 }PVR2DBLTINFO, *PPVR2DBLTINFO;
 
+
 typedef struct _PVR2DRECT
 {
-	long left, top;
-	long right, bottom;
-} PVR2DRECT;
+	PVR2D_LONG left, top;
+	PVR2D_LONG right, bottom;
+} PVR2DRECT, *PPVR2DRECT;
+
 
 typedef struct
 {
-	PVR2DMEMINFO	*pSurfMemInfo;		/* surface memory */
-	unsigned long	SurfOffset;			/* byte offset from start of allocation to destination surface pixel 0,0 */
-	long			Stride;				/* signed stride */
-	PVR2DFORMAT		Format;
-	unsigned long	SurfWidth;			/* surface size in pixels */
-	unsigned long	SurfHeight;
+	PVR2D_ULONG		uChromaPlane1;		/* YUV multiplane - byte offset from start of alloc to chroma plane 1 */
+	PVR2D_ULONG		uChromaPlane2;		/* YUV multiplane - byte offset from start of alloc to chroma plane 2 */
+	PVR2D_LONG		Reserved[2];		/* Reserved, must be zero */
 
-} PVR2D_SURFACE, *PPVR2D_SURFACE;
+} PVR2D_SURFACE_EXT, *PPVR2D_SURFACE_EXT;
 
 typedef struct
 {
-	unsigned long	*pUseCode;					/* USSE code */
-	unsigned long	UseCodeSize;				/* usse code size in bytes */
+	PVR2D_ULONG		*pUseCode;					/* USSE code */
+	PVR2D_ULONG		UseCodeSize;				/* usse code size in bytes */
 
 } PVR2D_USECODE, *PPVR2D_USECODE;
 
@@ -269,10 +400,28 @@
 	PVR2DRECT				rcDest;				/* destination rectangle */
 	PVR2DRECT				rcSource;			/* source rectangle */
 	PVR2D_HANDLE			hUseCode;			/* custom USE code (NULL implies source copy) */
-	unsigned long			UseParams[2];		/* per-blt params for use code */
+	PVR2D_ULONG				UseParams[2];		/* per-blt params for use code */
 
 } PVR2D_3DBLT, *PPVR2D_3DBLT;
 
+typedef struct
+{
+	PVR2D_SURFACE			sDst;						/* destination surface */
+	PVR2DRECT				rcDest;						/* destination rectangle; scaling is supported */
+	PVR2D_SURFACE			sSrc;						/* source surface */
+	PVR2DRECT				rcSource;					/* source rectangle; scaling is supported */
+	PPVR2D_SURFACE			pSrc2;						/* optional second source surface (NULL if not required) */
+	PVR2DRECT*				prcSource2;					/* optional pSrc2 rectangle */
+	PVR2D_HANDLE			hUseCode;					/* custom USSE shader code (NULL implies default source copy) */
+	PVR2D_ULONG				UseParams[2];				/* per-blt params for usse code */
+	PVR2D_ULONG				uiNumTemporaryRegisters;	/* no. of temporary registers used in custom shader code */
+	PVR2D_BOOL				bDisableDestInput;			/* set true if the destination is output only */
+	PPVR2D_SURFACE_EXT		pDstExt;					/* Extended format params for dest */
+	PPVR2D_SURFACE_EXT		pSrcExt[2];					/* Extended format params for source 1 and 2 */
+	PVR2D_LONG				Reserved[4];				/* Reserved, must be zero */
+
+} PVR2D_3DBLT_EXT, *PPVR2D_3DBLT_EXT;
+
 
 #define MAKE_COPY_BLIT(src,soff,dest,doff,sx,sy,dx,dy,sz)
 
@@ -345,25 +494,50 @@
 /* Heap number for PVR2DGetFrameBuffer */
 #define PVR2D_FB_PRIMARY_SURFACE 0
 
-#define PVR2D_PRESENT_PROPERTY_SRCSTRIDE	(1 << 0)
-#define PVR2D_PRESENT_PROPERTY_DSTSIZE		(1 << 1)
-#define PVR2D_PRESENT_PROPERTY_DSTPOS		(1 << 2)
-#define PVR2D_PRESENT_PROPERTY_CLIPRECTS	(1 << 3)
-#define PVR2D_PRESENT_PROPERTY_INTERVAL		(1 << 4)
-
-
-#define PVR2D_CREATE_FLIPCHAIN_SHARED		(1 << 0)
-#define PVR2D_CREATE_FLIPCHAIN_QUERY		(1 << 1)
+#define PVR2D_PRESENT_PROPERTY_SRCSTRIDE	(1UL << 0)
+#define PVR2D_PRESENT_PROPERTY_DSTSIZE		(1UL << 1)
+#define PVR2D_PRESENT_PROPERTY_DSTPOS		(1UL << 2)
+#define PVR2D_PRESENT_PROPERTY_CLIPRECTS	(1UL << 3)
+#define PVR2D_PRESENT_PROPERTY_INTERVAL		(1UL << 4)
+
+#define PVR2D_CREATE_FLIPCHAIN_SHARED		(1UL << 0)
+#define PVR2D_CREATE_FLIPCHAIN_QUERY		(1UL << 1)
+#define PVR2D_CREATE_FLIPCHAIN_OEMOVERLAY   (1UL << 2)
+#define PVR2D_CREATE_FLIPCHAIN_AS_BLITCHAIN (1UL << 3)
+
+/* Colour-key colour must be translated into argb8888 format */
+#define CKEY_8888(P)		(P)
+#define CKEY_4444(P)		(((P&0xF000UL)<<16) | ((P&0x0F00UL)<<12) | ((P&0x00F0UL)<<8) | ((P&0x000FUL)<<4))
+#define CKEY_1555(P)		(((P&0x8000UL)<<16) | ((P&0x7C00UL)<<9)  | ((P&0x3E0UL)<<6)  | ((P&0x1FUL)<<3))
+#define CKEY_565(P)			(((P&0xF800UL)<<8)  | ((P&0x7E0UL)<<5)   | ((P&0x1FUL)<<3))
+#define CKEY_MASK_8888		0x00FFFFFFUL
+#define CKEY_MASK_4444		0x00F0F0F0UL
+#define CKEY_MASK_1555		0x00F8F8F8UL	/* Alpha is not normally included in the key test */
+#define CKEY_MASK_565		0x00F8FCF8UL
+
+/* Fill colours must be translated into argb8888 format */
+#define CFILL_4444(P)		(((P&0xF000UL)<<16) | ((P&0x0F00UL)<<12) | ((P&0x00F0UL)<<8) | ((P&0x000FUL)<<4))
+#define CFILL_1555(P)		(((P&0x8000UL)<<16) | ((P&0x7C00UL)<<9)  | ((P&0x3E0UL)<<6)  | ((P&0x1FUL)<<3))
+#define CFILL_565(P)		(((P&0xF800UL)<<8)  | ((P&0x7E0UL)<<5)   | ((P&0x1FUL)<<3))
+
+/* PVR2DCreateDeviceContext flags */
+#define PVR2D_XSERVER_PROC			0x00000001UL		/* Set for the Xserver connection */
+#define PVR2D_FLAGS_PDUMP_ACTIVE	0x00000002UL		/* Set when pdumping from multiple processes */
+
+/* PVR2DMemAlloc flags */
+#define PVR2D_MEM_UNCACHED			0x00000000UL	/* Default */
+#define PVR2D_MEM_CACHED			0x00000001UL	/* Caller must flush and sync when necessary */
+#define PVR2D_MEM_WRITECOMBINE		0x00000002UL
 
 /* Functions that the library exports */
 
 PVR2D_IMPORT
-int PVR2DEnumerateDevices(PVR2DDEVICEINFO *pDevInfo);
+PVR2D_INT PVR2DEnumerateDevices(PVR2DDEVICEINFO *pDevInfo);
 
 PVR2D_IMPORT
-PVR2DERROR PVR2DCreateDeviceContext(unsigned long ulDevID,
+PVR2DERROR PVR2DCreateDeviceContext(PVR2D_ULONG ulDevID,
 									PVR2DCONTEXTHANDLE* phContext,
-									unsigned long ulFlags);
+									PVR2D_ULONG ulFlags);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DDestroyDeviceContext(PVR2DCONTEXTHANDLE hContext);
@@ -373,37 +547,47 @@
 							  PVR2DDISPLAYINFO *pDisplayInfo);
 
 PVR2D_IMPORT
+PVR2DERROR PVR2DGetMiscDisplayInfo(PVR2DCONTEXTHANDLE hContext,
+							  PVR2DMISCDISPLAYINFO *pMiscDisplayInfo);
+
+PVR2D_IMPORT
 PVR2DERROR PVR2DGetScreenMode(PVR2DCONTEXTHANDLE hContext,
 							  PVR2DFORMAT *pFormat,
-							  long *plWidth,
-							  long *plHeight,
-							  long *plStride,
-							  int *piRefreshRate);
+							  PVR2D_LONG *plWidth,
+							  PVR2D_LONG *plHeight,
+							  PVR2D_LONG *plStride,
+							  PVR2D_INT *piRefreshRate);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DGetFrameBuffer(PVR2DCONTEXTHANDLE hContext,
-							   int nHeap,
+							   PVR2D_INT nHeap,
 							   PVR2DMEMINFO **ppsMemInfo);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DMemAlloc(PVR2DCONTEXTHANDLE hContext,
-						 unsigned long ulBytes,
-						 unsigned long ulAlign,
-						 unsigned long ulFlags,
+						 PVR2D_ULONG ulBytes,
+						 PVR2D_ULONG ulAlign,
+						 PVR2D_ULONG ulFlags,
 						 PVR2DMEMINFO **ppsMemInfo);
 
 PVR2D_IMPORT
+PVR2DERROR PVR2DMemExport(PVR2DCONTEXTHANDLE hContext,
+						 PVR2D_ULONG ulFlags,
+						 PVR2DMEMINFO *psMemInfo,
+						 PVR2D_HANDLE *phMemHandle);
+
+PVR2D_IMPORT
 PVR2DERROR PVR2DMemWrap(PVR2DCONTEXTHANDLE hContext,
-						void *pMem,
-						unsigned long ulFlags,
-						unsigned long ulBytes,
-						unsigned long alPageAddress[],
+						PVR2D_VOID *pMem,
+						PVR2D_ULONG ulFlags,
+						PVR2D_ULONG ulBytes,
+						PVR2D_ULONG alPageAddress[],
 						PVR2DMEMINFO **ppsMemInfo);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DMemMap(PVR2DCONTEXTHANDLE hContext,
-						unsigned long ulFlags,
-						void *hPrivateMapData,
+						PVR2D_ULONG ulFlags,
+						PVR2D_HANDLE hMemHandle,
 						PVR2DMEMINFO **ppsDstMem);
 
 PVR2D_IMPORT
@@ -417,40 +601,44 @@
 PVR2D_IMPORT
 PVR2DERROR PVR2DBltClipped(PVR2DCONTEXTHANDLE hContext,
 						   PVR2DBLTINFO *pBltInfo,
-						   unsigned long ulNumClipRects,
+						   PVR2D_ULONG ulNumClipRects,
 						   PVR2DRECT *pClipRects);
 
+PVR2D_EXPORT
+PVR2DERROR PVR2DSet1555Alpha (PVR2DCONTEXTHANDLE hContext,
+							  PVR2D_UCHAR Alpha0, PVR2D_UCHAR Alpha1);
+
 PVR2D_IMPORT
 PVR2DERROR PVR2DQueryBlitsComplete(PVR2DCONTEXTHANDLE hContext,
-								   PVR2DMEMINFO *pMemInfo,
-								   unsigned int uiWaitForComplete);
+								   const PVR2DMEMINFO *pMemInfo,
+								   PVR2D_UINT uiWaitForComplete);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DSetPresentBltProperties(PVR2DCONTEXTHANDLE hContext,
-										unsigned long ulPropertyMask,
-										long lSrcStride,
-										unsigned long ulDstWidth,
-										unsigned long ulDstHeight,
-										long lDstXPos,
-										long lDstYPos,
-										unsigned long ulNumClipRects,
+										PVR2D_ULONG ulPropertyMask,
+										PVR2D_LONG lSrcStride,
+										PVR2D_ULONG ulDstWidth,
+										PVR2D_ULONG ulDstHeight,
+										PVR2D_LONG lDstXPos,
+										PVR2D_LONG lDstYPos,
+										PVR2D_ULONG ulNumClipRects,
 										PVR2DRECT *pClipRects,
-										unsigned long ulSwapInterval);
+										PVR2D_ULONG ulSwapInterval);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DPresentBlt(PVR2DCONTEXTHANDLE hContext,
 						   PVR2DMEMINFO *pMemInfo,
-						   long lRenderID);
+						   PVR2D_LONG lRenderID);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DCreateFlipChain(PVR2DCONTEXTHANDLE hContext,
-								unsigned long ulFlags,
-								unsigned long ulNumBuffers,
-								unsigned long ulWidth,
-								unsigned long ulHeight,
+								PVR2D_ULONG ulFlags,
+								PVR2D_ULONG ulNumBuffers,
+								PVR2D_ULONG ulWidth,
+								PVR2D_ULONG ulHeight,
 								PVR2DFORMAT eFormat,
-								long *plStride,
-								unsigned long *pulFlipChainID,
+								PVR2D_LONG *plStride,
+								PVR2D_ULONG *pulFlipChainID,
 								PVR2DFLIPCHAINHANDLE *phFlipChain);
 
 PVR2D_IMPORT
@@ -460,37 +648,78 @@
 PVR2D_IMPORT
 PVR2DERROR PVR2DGetFlipChainBuffers(PVR2DCONTEXTHANDLE hContext,
 									PVR2DFLIPCHAINHANDLE hFlipChain,
-									unsigned long *pulNumBuffers,
+									PVR2D_ULONG *pulNumBuffers,
 									PVR2DMEMINFO *psMemInfo[]);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DSetPresentFlipProperties(PVR2DCONTEXTHANDLE hContext,
 										 PVR2DFLIPCHAINHANDLE hFlipChain,
-										 unsigned long ulPropertyMask,
-										 long lDstXPos,
-										 long lDstYPos,
-										 unsigned long ulNumClipRects,
+										 PVR2D_ULONG ulPropertyMask,
+										 PVR2D_LONG lDstXPos,
+										 PVR2D_LONG lDstYPos,
+										 PVR2D_ULONG ulNumClipRects, 
 										 PVR2DRECT *pClipRects,
-										 unsigned long ulSwapInterval);
+										 PVR2D_ULONG ulSwapInterval);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DPresentFlip(PVR2DCONTEXTHANDLE hContext,
 							PVR2DFLIPCHAINHANDLE hFlipChain,
 							PVR2DMEMINFO *psMemInfo,
-							long lRenderID);
+							PVR2D_LONG lRenderID);
 
 PVR2D_IMPORT
-PVR2DERROR PVR2DGetAPIRev(long *lRevMajor, long *lRevMinor);
+PVR2DERROR PVR2DGetAPIRev(PVR2D_LONG *lRevMajor, PVR2D_LONG *lRevMinor);
 
 PVR2D_IMPORT
-PVR2DERROR PVR2DLoadUseCode (const PVR2DCONTEXTHANDLE hContext, const unsigned char	*pUseCode,
-									const unsigned long UseCodeSize, PVR2D_HANDLE *pUseCodeHandle);
+PVR2DERROR PVR2DLoadUseCode (const PVR2DCONTEXTHANDLE hContext, const PVR2D_UCHAR	*pUseCode,
+									const PVR2D_ULONG UseCodeSize, PVR2D_HANDLE *pUseCodeHandle);
 PVR2D_IMPORT
 PVR2DERROR PVR2DFreeUseCode (const PVR2DCONTEXTHANDLE hContext, const PVR2D_HANDLE hUseCodeHandle);
 
 PVR2D_IMPORT
 PVR2DERROR PVR2DBlt3D (const PVR2DCONTEXTHANDLE hContext, const PPVR2D_3DBLT pBlt3D);
 
+PVR2D_IMPORT
+PVR2DERROR PVR2DBlt3DExt (const PVR2DCONTEXTHANDLE hContext, const PPVR2D_3DBLT_EXT pBlt3D);
+
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DModifyPendingOps(const PVR2DCONTEXTHANDLE hContext,
+								 PVR2D_HANDLE *phSyncModObj,
+								 PVR2DMEMINFO *psMemInfo,
+								 PVR2D_BOOL  bIsWriteOp,
+								 PVR2D_ULONG *pulReadOpsPending,
+								 PVR2D_ULONG *pulWriteOpsPending);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DModifyCompleteOps(const PVR2DCONTEXTHANDLE hContext,
+								  PVR2D_HANDLE hSyncModObj);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DFlushToSyncModObj(const PVR2DCONTEXTHANDLE hContext,
+								  PVR2D_HANDLE hSyncModObj,
+								  PVR2D_BOOL bWait);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DTakeSyncToken(const PVR2DCONTEXTHANDLE hContext,
+							  PVR2DMEMINFO *psMemInfo,
+							  PVR2D_HANDLE *phSyncToken,
+							  PVR2D_ULONG *pulReadOpsPending,
+							  PVR2D_ULONG *pulWriteOpsPending);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DReleaseSyncToken(const PVR2DCONTEXTHANDLE hContext,
+								 PVR2D_HANDLE hSyncToken);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DFlushToSyncToken(const PVR2DCONTEXTHANDLE hContext,
+								 PVR2DMEMINFO *psMemInfo,
+								 PVR2D_HANDLE hSyncToken,
+								 PVR2D_BOOL bWait);
+
+PVR2D_IMPORT
+PVR2DERROR PVR2DWaitForNextHardwareEvent(const PVR2DCONTEXTHANDLE hContext);
+
 #ifdef __cplusplus
 }
 #endif 
diff -uNr qt-everywhere-opensource-src-4.8.5.org/src/3rdparty/powervr/wsegl.h qt-everywhere-opensource-src-4.8.5/src/3rdparty/powervr/wsegl.h
--- qt-everywhere-opensource-src-4.8.5.org/src/3rdparty/powervr/wsegl.h	2013-06-07 07:16:52.000000000 +0200
+++ qt-everywhere-opensource-src-4.8.5/src/3rdparty/powervr/wsegl.h	2013-12-16 13:53:14.268554868 +0100
@@ -1,33 +1,67 @@
-/******************************************************************************
- Name         : wsegl.h
- Copyright    :	Copyright (c) Imagination Technologies Limited.
-				This specification is protected by copyright laws and contains
-				material proprietary to Imagination Technologies Limited.
-				You may use and distribute this specification free of charge for implementing
-				the functionality therein, without altering or removing any trademark, copyright,
-				or other notice from the specification.
- Platform     : ANSI
-*****************************************************************************/
+/*************************************************************************/ /*!
+@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
+@License        Dual MIT/GPLv2
+
+The contents of this file are subject to the MIT license as set out below.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+Alternatively, the contents of this file may be used under the terms of
+the GNU General Public License Version 2 ("GPL") in which case the provisions
+of GPL are applicable instead of those above.
+
+If you wish to allow use of your version of this file only under the terms of
+GPL, and not to allow others to use your version of this file under the terms
+of the MIT license, indicate your decision by deleting the provisions above
+and replace them with the notice and other provisions required by GPL as set
+out in the file called "GPL-COPYING" included in this distribution. If you do
+not delete the provisions above, a recipient may use your version of this file
+under the terms of either the MIT license or GPL.
+ 
+This License is also included in this distribution in the file called
+"MIT-COPYING".
+
+EXCEPT AS OTHERWISE STATED IN A NEGOTIATED AGREEMENT: (A) THE SOFTWARE IS
+PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
+BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT; AND (B) IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
+*/ /**************************************************************************/
 
 #if !defined(__WSEGL_H__)
 #define __WSEGL_H__
 
 #ifdef __cplusplus
 extern "C" {
-#endif 
+#endif
 
 /*
 // WSEGL Platform-specific definitions
 */
+#if defined(__linux__)
+#define WSEGL_EXPORT __attribute__((visibility("default")))
+#define WSEGL_IMPORT
+#else
 #define WSEGL_EXPORT
 #define WSEGL_IMPORT
+#endif
 
 /*
 // WSEGL API Version Number
 */
 
-#define WSEGL_VERSION 1
+#define WSEGL_VERSION 4
 #define WSEGL_DEFAULT_DISPLAY 0
 #define WSEGL_DEFAULT_NATIVE_ENGINE 0
 
@@ -54,6 +88,11 @@
 	WSEGL_CAP_WINDOWS_USE_HW_SYNC = 3, /* System default value = 0 (FALSE) */
 	WSEGL_CAP_PIXMAPS_USE_HW_SYNC = 4, /* System default value = 0 (FALSE) */
 
+	/* When this capability is set, the EGL lock is not taken around calls
+	   to WSEGL functions. The WSEGL module is responsible for performing
+	   its own locking in this case. */
+	WSEGL_CAP_UNLOCKED = 5, /* System default value = 0 */
+
 } WSEGLCapsType;
 
 /*
@@ -73,16 +112,50 @@
 #define WSEGL_DRAWABLE_WINDOW		0x1
 #define WSEGL_DRAWABLE_PIXMAP		0x2
 
+/*
+// YUV format flags and sync
+*/
+#define WSEGL_FLAGS_YUV_CONFORMANT_RANGE		(0 << 0)
+#define WSEGL_FLAGS_YUV_FULL_RANGE				(1 << 0)
+#define WSEGL_FLAGS_YUV_BT601					(0 << 1)
+#define WSEGL_FLAGS_YUV_BT709					(1 << 1)
+#define WSEGL_FLAGS_EGLIMAGE_COMPOSITION_SYNC	(1 << 2)
+
+/*
+// Maximum number of optional PowerVR Services 4 SYNCINFO objects
+*/
+#define WSEGL_MAX_SRC_SYNCS 32
 
 /*
 // Pixel format of display/drawable
 */
 typedef enum WSEGLPixelFormat_TAG
 {
-	WSEGL_PIXELFORMAT_565 = 0,
-	WSEGL_PIXELFORMAT_4444 = 1,
-	WSEGL_PIXELFORMAT_8888 = 2,
-	WSEGL_PIXELFORMAT_1555 = 3
+	/* These must not be re-ordered */
+	WSEGL_PIXELFORMAT_RGB565	= 0,
+	WSEGL_PIXELFORMAT_ARGB4444	= 1,
+	WSEGL_PIXELFORMAT_ARGB8888	= 2,
+	WSEGL_PIXELFORMAT_ARGB1555	= 3,
+	WSEGL_PIXELFORMAT_ABGR8888	= 4,
+	WSEGL_PIXELFORMAT_XBGR8888	= 5,
+	WSEGL_PIXELFORMAT_NV12		= 6,
+	WSEGL_PIXELFORMAT_YUYV		= 7,
+	WSEGL_PIXELFORMAT_YV12		= 8,
+	WSEGL_PIXELFORMAT_XRGB8888	= 9,
+	WSEGL_PIXELFORMAT_UYVY		= 10,
+	WSEGL_PIXELFORMAT_NV12_4KALIGN = 11,
+	WSEGL_PIXELFORMAT_NV21_4KALIGN = 12,
+	WSEGL_PIXELFORMAT_R8		= 13,
+	WSEGL_PIXELFORMAT_R8G8		= 14,
+	WSEGL_PIXELFORMAT_NV21		= 15,
+
+	/* These are compatibility names only; new WSEGL
+	 * modules should not use them.
+	 */
+	WSEGL_PIXELFORMAT_565		= WSEGL_PIXELFORMAT_RGB565,
+	WSEGL_PIXELFORMAT_4444		= WSEGL_PIXELFORMAT_ARGB4444,
+	WSEGL_PIXELFORMAT_8888		= WSEGL_PIXELFORMAT_ARGB8888,
+	WSEGL_PIXELFORMAT_1555		= WSEGL_PIXELFORMAT_ARGB1555,
 
 } WSEGLPixelFormat;
 
@@ -105,29 +178,31 @@
 	// Type of drawables this configuration applies to -
 	// OR'd values of drawable types. 
 	*/
-	unsigned long ui32DrawableType;
+	unsigned long			ui32DrawableType;
 
 	/* Pixel format */
-	WSEGLPixelFormat ePixelFormat;
+	WSEGLPixelFormat		ePixelFormat;
 
 	/* Native Renderable  - set to WSEGL_TRUE if native renderable */
-	unsigned long ulNativeRenderable;
+	unsigned long			ulNativeRenderable;
 
 	/* FrameBuffer Level Parameter */
-	unsigned long ulFrameBufferLevel;
+	unsigned long			ulFrameBufferLevel;
 
 	/* Native Visual ID */
-	unsigned long ulNativeVisualID;
+	unsigned long			ulNativeVisualID;
 
 	/* Native Visual */
-	void *hNativeVisual;
+	unsigned long			ulNativeVisualType;
 
 	/* Transparent Type */
-	WSEGLTransparentType eTransparentType;
+	WSEGLTransparentType	eTransparentType;
 
 	/* Transparent Color - only used if transparent type is COLOR_KEY */
-	unsigned long ulTransparentColor; /* packed as 0x00RRGGBB */
+	unsigned long			ulTransparentColor; /* packed as 0x00RRGGBB */
 
+	/* Framebuffer Target - set to WSEGL_TRUE if config compatible with framebuffer */
+	unsigned long			ulFramebufferTarget;
 
 } WSEGLConfig;
 
@@ -143,8 +218,14 @@
 	WSEGL_BAD_NATIVE_PIXMAP = 4,
 	WSEGL_BAD_NATIVE_ENGINE = 5,
 	WSEGL_BAD_DRAWABLE = 6,
-	WSEGL_BAD_CONFIG = 7,
-	WSEGL_OUT_OF_MEMORY = 8
+	WSEGL_BAD_MATCH = 7,
+	WSEGL_OUT_OF_MEMORY = 8,
+	WSEGL_RETRY = 9,
+
+	/* These are compatibility names only; new WSEGL
+	 * modules should not use them.
+	 */
+	WSEGL_BAD_CONFIG = WSEGL_BAD_MATCH,
 
 } WSEGLError; 
 
@@ -166,25 +247,46 @@
 typedef struct WSEGLDrawableParams_TAG
 {
 	/* Width in pixels of the drawable */
-	unsigned long	ui32Width;
+	unsigned long			ui32Width;
 
 	/* Height in pixels of the drawable */
-	unsigned long	ui32Height;
+	unsigned long			ui32Height;
 
 	/* Stride in pixels of the drawable */
-	unsigned long	ui32Stride;
+	unsigned long			ui32Stride;
 
 	/* Pixel format of the drawable */
-	WSEGLPixelFormat	ePixelFormat;
+	WSEGLPixelFormat		ePixelFormat;
 
 	/* User space cpu virtual address of the drawable */
-	void   			*pvLinearAddress;
+	void   					*pvLinearAddress;
 
 	/* HW address of the drawable */
-	unsigned long	ui32HWAddress;
+	unsigned long			ui32HWAddress;
+
+	/* Override display's HW_SYNC mode */
+	unsigned long			bWaitForRender;
 
-	/* Private data for the drawable */
-	void			*hPrivateData;
+	/* Flags */
+	unsigned long			ulFlags;
+
+	/* Rotation angle of drawable (presently source only) */
+	WSEGLRotationAngle		eRotationAngle;
+
+	/*
+	// Optional PowerVR Services 4 MEMINFO pointer. This may be used for
+	// internal (implicit) synchronization purposes, and by PDUMP. It should
+	// refer to the same object as the other fields in this structure.
+	*/
+	void					*hMemInfo;
+
+	/*
+	// Optional PowerVR Services 4 SYNCINFO pointers to sent down as source
+	// surface (texture) dependencies of a render. If these are provided
+	// when not applicable, they will be ignored. If a sync is not needed,
+	// it should be passed as NULL.
+	*/
+	void					*ahSyncInfo[WSEGL_MAX_SRC_SYNCS];
 
 } WSEGLDrawableParams;
 
@@ -221,8 +323,18 @@
 
 	WSEGLError (*pfnWSEGL_CopyFromPBuffer)(void *, unsigned long, unsigned long, unsigned long, WSEGLPixelFormat, NativePixmapType);
 
-	WSEGLError (*pfnWSEGL_GetDrawableParameters)(WSEGLDrawableHandle, WSEGLDrawableParams *, WSEGLDrawableParams *);
+	WSEGLError (*pfnWSEGL_GetDrawableParameters)(WSEGLDrawableHandle, WSEGLDrawableParams *, WSEGLDrawableParams *, unsigned long);
+
+	WSEGLError (*pfnWSEGL_ConnectDrawable)(WSEGLDrawableHandle);
+
+	WSEGLError (*pfnWSEGL_DisconnectDrawable)(WSEGLDrawableHandle);
+
+	WSEGLError (*pfnWSEGL_FlagStartFrame)(void);
+
 
+#if defined (__QNXNTO__)
+	WSEGLError (*pfnWSEGL_WaitForDrawableRenderBuffer)(WSEGLDrawableHandle);
+#endif
 
 } WSEGL_FunctionTable;
 
diff -uNr qt-everywhere-opensource-src-4.8.5.org/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c qt-everywhere-opensource-src-4.8.5/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c
--- qt-everywhere-opensource-src-4.8.5.org/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c	2013-06-07 07:17:00.000000000 +0200
+++ qt-everywhere-opensource-src-4.8.5/src/plugins/gfxdrivers/powervr/QWSWSEGL/pvrqwswsegl.c	2013-12-16 13:51:28.795001808 +0100
@@ -336,12 +336,17 @@
 /* Return the parameters of a drawable that are needed by the EGL layer */
 static WSEGLError wseglGetDrawableParameters
     (WSEGLDrawableHandle _drawable, WSEGLDrawableParams *sourceParams,
-     WSEGLDrawableParams *renderParams)
+     WSEGLDrawableParams *renderParams,unsigned long ulPlaneOffset)
 {
     PvrQwsDrawable *drawable = (PvrQwsDrawable *)_drawable;
     PVR2DMEMINFO *source, *render;
     WSEGLPixelFormat pixelFormat;
 
+    WSEGL_UNREFERENCED_PARAMETER(ulPlaneOffset);
+
+	memset(renderParams, 0, sizeof(*renderParams));
+	memset(sourceParams, 0, sizeof(*sourceParams));
+
     if (!pvrQwsGetBuffers(drawable, &source, &render))
         return WSEGL_BAD_DRAWABLE;
 
@@ -366,7 +371,7 @@
     sourceParams->ePixelFormat = pixelFormat;
     sourceParams->pvLinearAddress = source->pBase;
     sourceParams->ui32HWAddress = source->ui32DevAddr;
-    sourceParams->hPrivateData = source->hPrivateData;
+    sourceParams->hMemInfo = source->hPrivateData;
 
     renderParams->ui32Width = drawable->rect.width;
     renderParams->ui32Height = drawable->rect.height;
@@ -374,11 +379,34 @@
     renderParams->ePixelFormat = pixelFormat;
     renderParams->pvLinearAddress = render->pBase;
     renderParams->ui32HWAddress = render->ui32DevAddr;
-    renderParams->hPrivateData = render->hPrivateData;
+    renderParams->hMemInfo = render->hPrivateData;
+
+    return WSEGL_SUCCESS;
+}
 
+static WSEGLError wseglConnectDrawable(WSEGLDrawableHandle hDrawable){
+    WSEGL_UNREFERENCED_PARAMETER(hDrawable);
     return WSEGL_SUCCESS;
 }
 
+static WSEGLError wseglDisconnectDrawable(WSEGLDrawableHandle hDrawable){
+    WSEGL_UNREFERENCED_PARAMETER(hDrawable);
+    return WSEGL_SUCCESS;
+}
+/***********************************************************************************
+ Function Name      : WSEGL_FlagStartFrame
+ Inputs             : hDrawable
+ Outputs            : None
+ Returns            : Error code
+ Description        : Indicates that there have been rendering commands submitted
+                                          by a client driver
+************************************************************************************/
+static WSEGLError wseglFlagStartFrame(void)
+{
+        return WSEGL_SUCCESS;
+}
+
+
 static WSEGL_FunctionTable const wseglFunctions = {
     WSEGL_VERSION,
     wseglIsDisplayValid,
@@ -392,7 +420,10 @@
     wseglWaitNative,
     wseglCopyFromDrawable,
     wseglCopyFromPBuffer,
-    wseglGetDrawableParameters
+    wseglGetDrawableParameters,
+    wseglConnectDrawable,
+    wseglDisconnectDrawable,
+    wseglFlagStartFrame
 };
 
 /* Return the table of WSEGL functions to the EGL implementation */